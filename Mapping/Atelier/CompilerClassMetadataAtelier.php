<?php

/**
 * This file is part of the Flaphl package.
 *
 * (c) Jade Phyressi <jade@flaphl.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Flaphl\Element\Reissue\Mapping\Atelier;

use Flaphl\Element\Reissue\Mapping\ClassMetadata;
use Flaphl\Element\Reissue\Mapping\AttributeMetadata;

/**
 * Compiled class metadata factory with pre-loaded metadata.
 * This is generated by ClassMetadataAtelierCompiler for production use.
 *
 * @author Jade Phyressi <jade@flaphl.com>
 */
class CompilerClassMetadataAtelier implements ClassMetadataAtelierInterface
{
    use ClassResolverTrait;

    /**
     * @var array<string, ClassMetadata>
     */
    private array $metadata = [];

    /**
     * @param array<string, array<string, mixed>> $compiledMetadata Pre-compiled metadata
     */
    public function __construct(array $compiledMetadata = [])
    {
        foreach ($compiledMetadata as $className => $data) {
            $this->metadata[$className] = $this->hydrateMetadata($className, $data);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getMetadataFor(string|object $value): ClassMetadata
    {
        $className = $this->resolveClassName($value);

        if (!isset($this->metadata[$className])) {
            // If not pre-compiled, create empty metadata
            $this->metadata[$className] = new ClassMetadata($className);
        }

        return $this->metadata[$className];
    }

    /**
     * {@inheritdoc}
     */
    public function hasMetadataFor(string|object $value): bool
    {
        $className = $this->resolveClassName($value);
        return isset($this->metadata[$className]);
    }

    /**
     * Hydrates ClassMetadata from compiled data.
     *
     * @param string $className The class name
     * @param array<string, mixed> $data The compiled metadata data
     */
    private function hydrateMetadata(string $className, array $data): ClassMetadata
    {
        $metadata = new ClassMetadata($className);

        foreach ($data['attributes'] ?? [] as $attributeName => $attributeData) {
            $attributeMetadata = new AttributeMetadata($attributeName);

            if (isset($attributeData['ignored'])) {
                $attributeMetadata->setIgnored($attributeData['ignored']);
            }

            if (isset($attributeData['serialized_name'])) {
                $attributeMetadata->setSerializedName($attributeData['serialized_name']);
            }

            if (isset($attributeData['groups'])) {
                $attributeMetadata->setGroups($attributeData['groups']);
            }

            if (isset($attributeData['max_depth'])) {
                $attributeMetadata->setMaxDepth($attributeData['max_depth']);
            }

            $metadata->addAttributeMetadata($attributeMetadata);
        }

        return $metadata;
    }

    /**
     * Exports the current metadata to compilable array format.
     *
     * @return array<string, array<string, mixed>>
     */
    public function export(): array
    {
        $exported = [];

        foreach ($this->metadata as $className => $metadata) {
            $attributes = [];

            foreach ($metadata->getAttributesMetadata() as $attributeName => $attributeMetadata) {
                $attributes[$attributeName] = [
                    'ignored' => $attributeMetadata->isIgnored(),
                    'serialized_name' => $attributeMetadata->getSerializedName(),
                    'groups' => $attributeMetadata->getGroups(),
                    'max_depth' => $attributeMetadata->getMaxDepth(),
                ];
            }

            $exported[$className] = [
                'attributes' => $attributes,
            ];
        }

        return $exported;
    }
}
